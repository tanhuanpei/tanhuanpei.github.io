{"meta":{"title":"littletank's house","subtitle":null,"description":null,"author":"HuanPei Tan","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-07-24T09:26:45.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"但行好事，莫问前程 GitHub"}],"posts":[{"title":"Android性能优化【应用启动优化与白屏源码分析】","slug":"Android性能优化【应用启动优化与白屏源码分析】","date":"2019-01-08T14:01:27.000Z","updated":"2019-01-08T14:03:34.388Z","comments":true,"path":"2019/01/08/Android性能优化【应用启动优化与白屏源码分析】/","link":"","permalink":"http://yoursite.com/2019/01/08/Android性能优化【应用启动优化与白屏源码分析】/","excerpt":"","text":"白屏是什么？在Android系统中，Activity组件在启动之后，并且在它的窗口显示出来之前，可以显示一个启动窗口。这个启动窗口可以看作是Activity组件的预览窗口，是由WindowManagerService服务统一管理的，即由WindowManagerService服务负责启动和结束。Activity组件的启动窗口是由ActivityManagerService服务来决定是否要显示的。如果需要显示，那么ActivityManagerService服务就会通知WindowManagerService服务来为正在启动的Activity组件显示一个启动窗口，而WindowManagerService服务又是通过窗口管理策略类PhoneWindowManager来创建这个启动窗口的。这个过程如图所示。 窗口管理策略类PhoneWindowManager创建完成Activity组件的启动窗口之后，就会请求WindowManagerService服务将该启动窗口显示出来。当Activity组件启动完成，并且它的窗口也显示出来的时候，WindowManagerService服务就会结束显示它的启动窗口。 如何检测App启动时间ADB命令adb shell am start -W -S com.xrom.intl.appcenter/com.xrom.intl.appcenter.ui.main.MainActivity12345Activity: com.xrom.intl.appcenter/.ui.main.MainActivityThisTime: 1258TotalTime: 1258WaitTime: 1328Complete WaitTime = endTime - startTime WaitTime就是总的耗时，包括前一个应用Activity pause的时间和新应用启动的时间；ThisTime表示一连串启动Activity的最后一个Activity的启动耗时；TotalTime表示新应用启动的耗时，包括新进程的启动和Activity的启动，但不包括前一个应用Activity pause的耗时。也就是说，开发者一般只要关心TotalTime即可，这个时间才是自己应用真正启动的耗时。 sysTrace工具Android的SDK开发包中platform-tools文件夹里包含了systrace工具，在使用命令之前可以配置参数和别名，避免重复敲命令。12alias st-start='python /home/tanhuanpei/IDE/Sdk/platform-tools/systrace/systrace.py'alias systrace='st-start -t 8 gfx input view sched freq wm am hwui workq res dalvik sync disk load perf hal rs idle mmc' 使用时1systrace -a com.xrom.intl.appcenter -o test.trace 启动时间分析使用adb命令和systrace命令生成test.trace文件 执行bindApplication从图中第一行可以看到,由于是第一次启动,这个应用的bindApplication方法被调用, 执行onCreate–onStart–onResume然后是activityStart方法,对应应用程序中的onCreate–onStart–onResume三个方法. 执行performTraversals紧接着会执行两次performTraversals方法(其源码位于Frameworks/base/core/java/android/view/ViewRootImpl.java), ViewRootImpl使用mFirst这个变量来标记是否是第一次启动.第一次执行performTraversals会执行mAttachInfo.mHardwareRenderer.initializ方法,初始化Surface. 第一次创建Surface之后,newSurface为true,从下面的代码来看会执行另一次performTraversals.这就是为什么启动应用的时候需要执行两次performTraversals.分析Trace图的时候也可以根据两次performTraversals执行的情况看出问题. 所以第二个performTraversals中会执行performDraw方法。 显示应用界面一般来说第二个performTraversals执行完成后, 表示应用程序的第一帧被绘制完成.一旦应用绘制完成,WMS会收到FINISHED_STARTING标记应用启动完成,这时会Remove掉Starting Window.这样应用就显示出来了. 应用启动优化的目标由于热启动和冷启动在优化方面的差异不大,就以最常见的的冷启动方式来确定优化的目标. 通过之前的知识可以知道,冷启动的耗时比较长,应用初始化的时间比较长.所以大部分人情况下Starting Window都是做完动画(即撑满屏幕)后,过一会儿才会被Remove掉. 从优化的角度来说,我们肯定是希望应用启动的时间越快越好.但是也要根据实际情况为其设置一个合理的数值. 启动优化的目标设定思路在手机使用方面,人的感官对于卡顿的感知是很灵敏的,同样对于加载时长的容忍也是很有限的,除非使用其他手段在加载时吸引用户的注意. 但是对于应用启动来说,用户的需求是非常明确的: 就是要快速打开应用,看到主界面.在用户点击到主界面显示,其中比较重要的可以优化的几个点: Starting Window的初始化 Starting Window的动画 应用的初始化时间 其中对应的可优化的点: 优化Starting Window的初始化时间(系统级优化) 优化Starting Window的动画(系统级优化,包括动画的时长,开始的大小,以及透明度等) 优化应用程序自身(应用级优化,包括精简onCreate/onStart/onResume函数,优化主界面的复杂度等) 从流畅性和连贯性的角度来说,如果在Starting Window刚好做完动画的时候,应用也初始化完成,这时候将Starting Window Remove掉.从用户的角度来看白屏没有停留,就显得很流畅. 从系统优化的角度来看,Android应用启动优化分为两个阶段的优化: 系统级服务的优化: ActivityManagerService的优化. WindowManagerService的优化. Touch Event的优化. Launcher的优化. 系统公共控件的优化. 应用相关的优化 应用布局优化. 懒加载: 即按需加载. 延迟加载: 即精简OnCreate函数. 参考链接怎么计算apk的启动时间","categories":[],"tags":[{"name":"性能优化 源码分析  白屏优化","slug":"性能优化-源码分析-白屏优化","permalink":"http://yoursite.com/tags/性能优化-源码分析-白屏优化/"}]},{"title":"Hexo简易教程","slug":"Hexo简易教程","date":"2018-12-18T07:55:18.031Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/12/18/Hexo简易教程/","link":"","permalink":"http://yoursite.com/2018/12/18/Hexo简易教程/","excerpt":"","text":"GitHub+Hexo 搭建个人网站详细教程 新建文章1$ hexo new \"My New Post\" 文章目录在 source/_posts/My Niew Post.mdMore info: Writing 启动本地服务器1$ hexo server 一般地址为 http://localhost:4000/More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程服务器1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Android架构组件-LiveData使用与源码分析","slug":"Android架构组件-LiveData使用与源码分析","date":"2018-12-18T07:39:37.000Z","updated":"2018-12-18T13:10:04.999Z","comments":true,"path":"2018/12/18/Android架构组件-LiveData使用与源码分析/","link":"","permalink":"http://yoursite.com/2018/12/18/Android架构组件-LiveData使用与源码分析/","excerpt":"","text":"前言LiveData是一个可以被观察的数据装载类。跟普通的被观察者不一样的，LiveData是具有生命周期感知功能，这意味它可以感知并遵循Activity,Fragment或者Service等组件的生命周期。这样的设计保证了LiveData仅当组件处于激活状态时才更新数据。 只有当 Observer 的 Lifecycle 对象处于 STARTED 或者 RESUMED 状态的时候， LiveData 才处于活动状态，只有在活动状态数据变化事件才会通知到 Observer。当处于DESTROYED状态的时候，Observer会被相应的移除。 LiveData的优点使用LiveData具有以下的有点： UI和实时数据保持一致 因为LiveData采用的是观察者模式，这样一来就可以在数据发生改变时获得通知，更新UI。避免内存泄漏- 观察者被绑定到组件的生命周期上，当被绑定的组件销毁（destroy）时，观察者会立刻自动清理自身的数据。不会再产生由于Activity处于stop状态而引起的崩溃- 例如：当Activity处于后台状态时，是不会收到LiveData的任何事件的。不需要再解决生命周期带来的问题- LiveData可以感知被绑定的组件的生命周期，只有在活跃状态才会通知数据变化。实时数据刷新- 当组件处于活跃状态或者从不活跃状态到活跃状态时总是能收到最新的数据。解决Configuration Change问题- 在屏幕发生旋转或者被回收再次启动，立刻就能收到最新的数据。资源共享- 通过使用单例模式和继承LiveData，可以实现一次发送，多个观察者更新数据。 添加LiveData添加google maven仓库在项目build.gradle中添加：123456allprojects &#123; repositories &#123; google() jcenter() &#125;&#125; AndroidX1234567891011121314dependencies &#123; def lifecycle_version = &quot;2.0.0&quot; // ViewModel and LiveData implementation &quot;androidx.lifecycle:lifecycle-extensions:$lifecycle_version&quot; // alternatively - just LiveData implementation &quot;androidx.lifecycle:lifecycle-livedata:$lifecycle_version&quot; // optional - ReactiveStreams support for LiveData implementation &quot;androidx.lifecycle:lifecycle-reactivestreams:$lifecycle_version&quot; // use -ktx for Kotlin // optional - Test helpers for LiveData testImplementation &quot;androidx.arch.core:core-testing:$lifecycle_version&quot;&#125; AndroidX之前12345678910111213dependencies &#123; def lifecycle_version = &quot;1.1.1&quot; // ViewModel and LiveData implementation &quot;android.arch.lifecycle:extensions:$lifecycle_version&quot; // alternatively - just LiveData implementation &quot;android.arch.lifecycle:livedata:$lifecycle_version&quot; // optional - ReactiveStreams support for LiveData implementation &quot;android.arch.lifecycle:reactivestreams:$lifecycle_version&quot; // optional - Test helpers for LiveData testImplementation &quot;android.arch.core:core-testing:$lifecycle_version&quot;&#125; 创建LiveData对象MutableLiveData1234567891011121314public class NameViewModel extends ViewModel &#123;// Create a LiveData with a Stringprivate MutableLiveData&lt;String&gt; mCurrentName; public MutableLiveData&lt;String&gt; getCurrentName() &#123; if (mCurrentName == null) &#123; mCurrentName = new MutableLiveData&lt;String&gt;(); &#125; return mCurrentName; &#125;// Rest of the ViewModel...&#125; 123456789101112131415161718192021222324252627public class NameActivity extends AppCompatActivity &#123; private NameViewModel mModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Other code to setup the activity... // Get the ViewModel. mModel = ViewModelProviders.of(this).get(NameViewModel.class); // Create the observer which updates the UI. final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; // Update the UI, in this case, a TextView. mNameTextView.setText(newName); &#125; &#125;; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. mModel.getCurrentName().observe(this, nameObserver); &#125;&#125; MediatorLiveData123456LiveData liveData1 = ...;LiveData liveData2 = ...;MediatorLiveData liveDataMerger = new MediatorLiveData&lt;&gt;();liveDataMerger.addSource(liveData1, value -&gt; liveDataMerger.setValue(value));liveDataMerger.addSource(liveData2, value -&gt; liveDataMerger.setValue(value)); 使用单例模式 1234567891011121314151617181920212223242526272829public class SingletonLiveData extends MutableLiveData&lt;String&gt; &#123; private static volatile SingletonLiveData instance; public SingletonLiveData() &#123; &#125; public static SingletonLiveData getInstance() &#123; if (instance != null) &#123; return instance; &#125; synchronized (SingletonLiveData.class) &#123; if (instance == null) &#123; instance = new SingletonLiveData(); &#125; &#125; return instance; &#125; @Override protected void onActive() &#123; super.onActive(); &#125; @Override protected void onInactive() &#123; super.onInactive(); &#125;&#125; 123456SingletonLiveData.getInstance().observe(this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable String s) &#123; &#125; &#125;); 1SingletonLiveData.getInstance().setValue(&quot;single&quot;); 简单说明LiveData中的几个重要方法：onActive() - ：当 LiveData 具有活动状态的 Observer 的时候会调用这个函数。在这个函数中，我们开始监听位置变化。onInactive()- ：当 LiveData 没有活动状态的 Observer 的时候会调用这个函数。所以在这个函数中取消更新位置来避免无所谓的耗电。setValue()- ： 当 LiveData 的数据变化的时候，调用这个函数。然后 LiveData 会通知活动状态的 Observer 数据变化了。postValue()- :当需要在非UI线程更新数据时调用此函数。 需要注意的是，当使用 LiveData 时，由于CREATED 和 RESUMED 状态都被认为是激活状态，所以我们需要在 onCreate 中设置 LiveData并开始监听，如果监听放到 onResume 函数中的话，当 Activity 暂停再次恢复的时候，会调用 onStart 和 onResume 导致 LiveData 的 onActive() 函数分别被调用两次。 数据转换LiveData 还支持简单的数据变换。目前在 Transformations 类中有 map 和 switchMap 两个变换函数。 map 是把一个数据类型变换为另外一个数据类型。 switchMap 是把一个数据变化为另外一个 LiveData 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); 12345678910111213141516class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; private final MutableLiveData&lt;String&gt; addressInput = new MutableLiveData(); public final LiveData&lt;String&gt; postalCode = Transformations.switchMap(addressInput, (address) -&gt; &#123; return repository.getPostCode(address); &#125;); public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository &#125; private void setInput(String address) &#123; addressInput.setValue(address); &#125;&#125; 原理分析下面，我们深入源码，简单分析LiveData如何做到生命周期感知。先从注册观察者入手，源码中LiveData的observe方法如下1234567891011121314151617@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); LifecycleBoundObserver existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; existing.owner != wrapper.owner) &#123; throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper);&#125; 从这段代码看出，当观察者所在的LifecycleOwner状态处于DESTROYED时，注册失败。当重复注册观察者时，会抛出IllegalArgumentException异常。通过这些验证后，向Lifecycle注册观察者observer，LifecycleBoundObserver只是observer的一个包装类。LifecycleOwner是一个接口，只有一个方法getLifecycle()，在Fragment、FragmentActivity、SupportActivity、LifecycleService中均实现了这个方法。 12345678910111213141516171819202122232425262728293031323334353637383940class LifecycleBoundObserver implements GenericLifecycleObserver &#123; public final LifecycleOwner owner; public final Observer&lt;T&gt; observer; public boolean active; public int lastVersion = START_VERSION; LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; this.owner = owner; this.observer = observer; &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(observer); return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner activeStateChanged(isActiveState(owner.getLifecycle().getCurrentState())); &#125; void activeStateChanged(boolean newActive) &#123; if (newActive == active) &#123; return; &#125; active = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += active ? 1 : -1; if (wasInactive &amp;&amp; active) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !active) &#123; onInactive(); &#125; if (active) &#123; dispatchingValue(this); &#125; &#125; &#125; 123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; 123456789101112131415161718192021222324252627282930public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner &#123; LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; void performStart() &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(); &#125; mState = STARTED; mCalled = false; onStart(); if (!mCalled) &#123; throw new SuperNotCalledException(\"Fragment \" + this + \" did not call through to super.onStart()\"); &#125; if (mChildFragmentManager != null) &#123; mChildFragmentManager.dispatchStart(); &#125; if (mLoaderManager != null) &#123; mLoaderManager.doReportStart(); &#125; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); &#125;&#125; LiveData中内部类LifecycleBoundObserver12345678910111213141516171819202122232425262728293031323334353637383940class LifecycleBoundObserver implements GenericLifecycleObserver &#123; public final LifecycleOwner owner; public final Observer&lt;T&gt; observer; public boolean active; public int lastVersion = START_VERSION; LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; this.owner = owner; this.observer = observer; &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(observer); return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner activeStateChanged(isActiveState(owner.getLifecycle().getCurrentState())); &#125; void activeStateChanged(boolean newActive) &#123; if (newActive == active) &#123; return; &#125; active = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += active ? 1 : -1; if (wasInactive &amp;&amp; active) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !active) &#123; onInactive(); &#125; if (active) &#123; dispatchingValue(this); &#125; &#125; &#125; LifecycleRegistry.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310public class LifecycleRegistry extends Lifecycle &#123; private static final String LOG_TAG = \"LifecycleRegistry\"; /** * Custom list that keeps observers and can handle removals / additions during traversal. * * Invariant: at any moment of time for observer1 &amp; observer2: * if addition_order(observer1) &lt; addition_order(observer2), then * state(observer1) &gt;= state(observer2), */ private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;(); /** * Current state */ private State mState; /** * The provider that owns this Lifecycle. * Only WeakReference on LifecycleOwner is kept, so if somebody leaks Lifecycle, they won't leak * the whole Fragment / Activity. However, to leak Lifecycle object isn't great idea neither, * because it keeps strong references on all other listeners, so you'll leak all of them as * well. */ private final WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner; private int mAddingObserverCounter = 0; private boolean mHandlingEvent = false; private boolean mNewEventOccurred = false; // we have to keep it for cases: // void onStart() &#123; // mRegistry.removeObserver(this); // mRegistry.add(newObserver); // &#125; // newObserver should be brought only to CREATED state during the execution of // this onStart method. our invariant with mObserverMap doesn't help, because parent observer // is no longer in the map. private ArrayList&lt;State&gt; mParentStates = new ArrayList&lt;&gt;(); /** * Creates a new LifecycleRegistry for the given provider. * &lt;p&gt; * You should usually create this inside your LifecycleOwner class's constructor and hold * onto the same instance. * * @param provider The owner LifecycleOwner */ public LifecycleRegistry(@NonNull LifecycleOwner provider) &#123; mLifecycleOwner = new WeakReference&lt;&gt;(provider); mState = INITIALIZED; &#125; /** * Moves the Lifecycle to the given state and dispatches necessary events to the observers. * * @param state new state */ @SuppressWarnings(\"WeakerAccess\") @MainThread public void markState(@NonNull State state) &#123; moveToState(state); &#125; /** * Sets the current state and notifies the observers. * &lt;p&gt; * Note that if the &#123;@code currentState&#125; is the same state as the last call to this method, * calling this method has no effect. * * @param event The event that was received */ public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next); &#125; private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false; &#125; private boolean isSynced() &#123; if (mObserverMap.size() == 0) &#123; return true; &#125; State eldestObserverState = mObserverMap.eldest().getValue().mState; State newestObserverState = mObserverMap.newest().getValue().mState; return eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState; &#125; private State calculateTargetState(LifecycleObserver observer) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer); State siblingState = previous != null ? previous.getValue().mState : null; State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1) : null; return min(min(mState, siblingState), parentState); &#125; @Override public void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--; &#125; private void popParentState() &#123; mParentStates.remove(mParentStates.size() - 1); &#125; private void pushParentState(State state) &#123; mParentStates.add(state); &#125; @Override public void removeObserver(@NonNull LifecycleObserver observer) &#123; // we consciously decided not to send destruction events here in opposition to addObserver. // Our reasons for that: // 1. These events haven't yet happened at all. In contrast to events in addObservers, that // actually occurred but earlier. // 2. There are cases when removeObserver happens as a consequence of some kind of fatal // event. If removeObserver method sends destruction events, then a clean up routine becomes // more cumbersome. More specific example of that is: your LifecycleObserver listens for // a web connection, in the usual routine in OnStop method you report to a server that a // session has just ended and you close the connection. Now let's assume now that you // lost an internet and as a result you removed this observer. If you get destruction // events in removeObserver, you should have a special case in your onStop method that // checks if your web connection died and you shouldn't try to report anything to a server. mObserverMap.remove(observer); &#125; /** * The number of observers. * * @return The number of observers. */ @SuppressWarnings(\"WeakerAccess\") public int getObserverCount() &#123; return mObserverMap.size(); &#125; @Override public State getCurrentState() &#123; return mState; &#125; static State getStateAfter(Event event) &#123; switch (event) &#123; case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException(\"Unexpected event value \" + event); &#125; private static Event downEvent(State state) &#123; switch (state) &#123; case INITIALIZED: throw new IllegalArgumentException(); case CREATED: return ON_DESTROY; case STARTED: return ON_STOP; case RESUMED: return ON_PAUSE; case DESTROYED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException(\"Unexpected state value \" + state); &#125; private static Event upEvent(State state) &#123; switch (state) &#123; case INITIALIZED: case DESTROYED: return ON_CREATE; case CREATED: return ON_START; case STARTED: return ON_RESUME; case RESUMED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException(\"Unexpected state value \" + state); &#125; private void forwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); &#125; &#125; &#125; private void backwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); &#125; &#125; &#125; // happens only on the top of stack (never in reentrance), // so it doesn't have to take in account parents private void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; Log.w(LOG_TAG, \"LifecycleOwner is garbage collected, you shouldn't try dispatch \" + \"new events from it.\"); return; &#125; while (!isSynced()) &#123; mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false; &#125; static State min(@NonNull State state1, @Nullable State state2) &#123; return state2 != null &amp;&amp; state2.compareTo(state1) &lt; 0 ? state2 : state1; &#125; static class ObserverWithState &#123; State mState; GenericLifecycleObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.getCallback(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125; &#125;&#125; 取Fragment举例，当Fragment状态切换调用perforStart()时，会执行LifecycleRegistry的handleLifecycleEvent()，然后依次调用moveToState()-&gt;sync()-&gt;forwardPass()-&gt;内部类ObserverWithState.dispatchEvent(LifecycleOwner owner, Event event)，然后调用LiveData中内部类LifecycleBoundObserver的onStateChanged()，当状态为DESTROYED时，自动解除绑定observer，实现了生命周期感知，避免内存泄露。 到这里，我们已经了解到LiveData绑定观察者和解绑观察者的流程。下面我们看下数据是怎么实现更新的。 1234567891011121314151617181920212223242526272829303132protected void setValue(T value) &#123; assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null); &#125;protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125;private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125; &#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void dispatchingValue(@Nullable LifecycleBoundObserver initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, LifecycleBoundObserver&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false; &#125;private void considerNotify(LifecycleBoundObserver observer) &#123; if (!observer.active) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!isActiveState(observer.owner.getLifecycle().getCurrentState())) &#123; observer.activeStateChanged(false); return; &#125; if (observer.lastVersion &gt;= mVersion) &#123; return; &#125; observer.lastVersion = mVersion; //noinspection unchecked observer.observer.onChanged((T) mData); &#125; 在LiveData中setVaule和postValue方法最终结果都是一样的，只是postValue提供给在非UI线程中调用。这里有个逻辑需要注意，在这篇文章中已经讲的很清晰，当LifeCircleOwner的状态发生变化的时候，会调用LiveData.ObserverWrapper的activeStateChanged函数，如果这个时候ObserverWrapper的状态是active，就会调用LiveData的dispatchingValue，接着调用considerNotify方法。在LiveData的considerNotify方法中，如果ObserverWrapper的mLastVersion小于LiveData的mVersion，就会去回调mObserver的onChanged方法。而每个新的订阅者，其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveDataBus每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。 总结上面已经介绍了LiveData的使用方法和通过源码分析一遍实现原理。通过LifecycleRegistry类将Fragment、Activity和Service组件的生命周期绑定到LiveData上，并通过观察者模式实现了数据的更新。","categories":[],"tags":[]},{"title":"Android性能优化【ANR机制总结与问题分析】","slug":"Android性能优化【ANR机制总结与问题分析】","date":"2018-09-12T12:36:22.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/09/12/Android性能优化【ANR机制总结与问题分析】/","link":"","permalink":"http://yoursite.com/2018/09/12/Android性能优化【ANR机制总结与问题分析】/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"工具汇总","slug":"工具汇总","date":"2018-08-01T02:54:12.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/08/01/工具汇总/","link":"","permalink":"http://yoursite.com/2018/08/01/工具汇总/","excerpt":"","text":"反编译Jadx","categories":[],"tags":[]},{"title":"Android性能优化【数据结构篇】","slug":"Android性能优化【数据结构篇】","date":"2018-07-27T07:42:56.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/07/27/Android性能优化【数据结构篇】/","link":"","permalink":"http://yoursite.com/2018/07/27/Android性能优化【数据结构篇】/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用AS开发gradle插件 (一)","slug":"使用AS开发gradle插件入门","date":"2018-07-05T11:45:51.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/07/05/使用AS开发gradle插件入门/","link":"","permalink":"http://yoursite.com/2018/07/05/使用AS开发gradle插件入门/","excerpt":"","text":"0X00 前言Gradle是一个使用Groovy语言实现的用于构建项目的框架。构建项目时真正起作用的是基于gradle框架使用Groovy实现的各种gradle插件。Gradle默认提供了很多插件，如Java-Plugin、Maven-Plugin等。Android Studio使用的是Android-Gradle-Plugin，由Google自主开发。在Android项目中，一个build.gradle文件，其实就是一个Groovy类。 0X01 在项目中使用Android gradle插件配置插件路径，在Project目录中的build.gradle添加123dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos;&#125; 使用具体插件，在主Module目录中的build.gradle添加1apply plugin: &apos;com.android.application&apos; 0X02 自定义插件我们可以利用Android Studio进行gradle插件开发，使用Groovy语言。简单步骤如下，1.新建一个Module，选择Android Library。2.删除src文件夹下的mian文件夹、删除build.gradle账文件中的所有内容。3.在src目录下创建 groovy和resources目录，resouces目录下创建META-INF/gradle-plugins目录。创建完后的文件目录结构如下图：4.修改Module中的 build.gradle文件，引入groovy和maven相关依赖1234567apply plugin: &apos;groovy&apos;apply plugin: &apos;maven&apos;dependencies &#123; compile gradleApi() compile localGroovy()&#125; 5.创建插件类TimeImpl.groovy，继承 Plugin&lt;Project&gt;，实现apply方法。 1234567public class TimeImpl implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; project.gradle.addListener(new TimeListener()) &#125;&#125; 在gradle-plugins文件夹下创建properties文件，文件名就是以后插件的名字。配置插件类1implementation-class = com.thp.plugin.TimeImpl 6.在build.gradle配置插件版本和发布到本地仓库 12345678910group = &apos;com.thp.plugin&apos;version = &apos;1.0.0&apos;uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri(&apos;../repo&apos;)) &#125; &#125;&#125; 这时候，右侧的gradle Toolbar就会在module下多出一个task 点击uploadArchives，项目目录多出repo文件夹，打开可以看到生成的gradle插件 0X03 项目中引用插件在app module的build.gradle上添加1234567891011121314buildscript &#123; repositories &#123; jcenter() maven &#123; url uri(&apos;../repo&apos;) &#125; &#125; dependencies &#123; classpath &apos;com.thp.plugin:gradletime:1.0.0&apos; &#125;&#125;apply plugin: &apos;gradle.time&apos; 以上，就是一个自定义插件的开发和引用流程。在这里，我们是引用本地生成的插件文件，下一篇将介绍如何上传到jcenter上，方便引用。 中文文档 深入理解Android之Gradle-邓凡平 Gradle User Guide 中文版 拥抱Android Studio系列 外籍文档 Groovy Documentation ：Groovy 的详细介绍文档 Groovy API Reference ：Groovy 的 API 文档 Gradle User Guid：Gradle 的详细介绍文档 Gradle Build Language Reference : Gradle DSL 参考，重点的几个 DSL 过一下，其他的用到再查 Android Plugin DSL Reference : 使用 Android 插件必备","categories":[],"tags":[{"name":"gradle插件","slug":"gradle插件","permalink":"http://yoursite.com/tags/gradle插件/"}]}]}