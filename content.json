{"meta":{"title":"littletank's house","subtitle":null,"description":null,"author":"HuanPei Tan","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-07-24T09:26:45.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"但行好事，莫问前程 GitHub"}],"posts":[{"title":"HTTPS握手过程详解与优化方法","slug":"HTTPS握手过程详解与优化方法","date":"2019-01-29T08:14:23.000Z","updated":"2019-01-29T09:01:43.780Z","comments":true,"path":"2019/01/29/HTTPS握手过程详解与优化方法/","link":"","permalink":"http://yoursite.com/2019/01/29/HTTPS握手过程详解与优化方法/","excerpt":"","text":"HTTPSHTTPS协议可以简单的认为是HTTP+TLS/SSL。SSL（Secure Socket Layer）是安全套接层，TLS（Transport Layer Security）是传输层安全协议，建立在SSL3.0协议规范，是SSL3.0的后续版本。当前最新使用的是TLS1.2协议。1.3版本还在草案阶段。 HTTPS 在 HTTP 下面提供了一个传输级的密码安全层——可以使用 SSL，也可以使用其后继者—— 传输层安全(Transport Layer Security，TLS)。由于 SSL 和 TLS 非常类似，所以我们不太严格地用术语 SSL 来表示 SSL 和 TLS。 TLS握手过程在传输应用数据之前，客户端与服务端经过协商秘钥、加密算法等信息，服务端还要把自己的证书发送给客户端以表明身份，这些环节构成了TLS握手过程，如下两图所示： 第一步ClientHello【client -&gt; server】 TLS版本 Client随机数Random1 session-id 加密算法套装列表 压缩算法 扩展字段，比如密码交换算法，请求主机名字等 第二步ServerHello【server -&gt; client】 TLS版本 Server随机数Random2 确定的加密套件，压缩算法 扩展字段 第三步Certificate, Server Key Exchange, Server Hello Done【server -&gt; client】 Certificate，CA证书 Server Key Exchange，密钥交换算法和相关数据 Server Hello Done，事件消息 第四步Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message【client -&gt; server】 Client Key Exchange，交换密钥参数 这里客户端会再生成一个随机数Random3。然后使用服务端传来的公钥进行加密得到密文PreMaster Key。服务端收到这个值后，使用私钥进行解密，得到Random3。这样客户端和服务端就都拥有了Random1、Random2和Random3。这样两边的秘钥就协商好了。后面数据传输就可以用协商好的秘钥进行加密和解密。 Change Cipher Spec，编码改变通知。 这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。 Encrypted Handshake Message 这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。 会话秘钥 = DES(random1+random2+rsa(ramdom3)) 第五步New Session Ticket, Change Cipher Spec, Encrypted Handshake Message【server -&gt; client】 New Session Ticket 包含了一个加密通信所需要的信息，这些数据采用一个只有服务端知道的密钥进行加密。目标是消除服务器需要维护每个客户端的会话状态缓存的要求。 Change Cipher Spec，编码改变通知 Encrypted Handshake Message 这一步对应的是Server Finish消息，服务端也会根据握手过程的消息生成摘要再用秘钥加密，这个服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一直的。 至此，双方SSL/TLS握手结束。 HTTPS优化 HTTP协议优化 HTTP2优势 升级HTTP2，HTTP2主要有以下特性： 二进制分帧，数据使用二进制传输，相比于文本传输，更利于解析和优化。 多路复用，同一域名下的请求，共用同一条链路进行传输，有效节省消耗。 头部优化，将头部字段缓存为索引，客户端与服务端维护索引表，通信过程中尽可能采用索引进行通信，收到索引后查询索引表，才能解析出真正的头部信息。 兼容性问题 需要注意的是，HTTP2在TLS层的协议协商使用的是NPN（Next Protocol Negotation）协议或者ALPN（Application Layer Protocol Negotation）协议。ALPN和NPN的主要区别在于：谁来决定通信协议。在ALPN的描述中，是让客户端先发送一个协议优先级列表给服务器，由服务器最终选择一个合适的。而NPN则正好相反，客户端有着最终的决定权。客户端和服务端都支持NPN或ALPN协商，是用上HTTP/2的大前提。 OkHttp是Square公司开源的客户端网络请求库，天然支持HTTP2，但在最新版本上，已经移除了对NPN协议的支持，转而只支持ALPN协议。ALPN协议只支持Android 5.0以上，如果在5.0以下支持HTTP2，必须使用NPN。 服务器理论上可以对NPN和ALPN同时支持，但部分服务器配置可能只支持NPN，并且短时间内不会支持ALPN，所以要用上HTTP2，必须使用NPN。 也就是说，根据服务器支持情况和手机系统版本决定是否开启HTTP2/。 TLS握手优化 Session Resumption，会话复用 Session Id，服务端开启 Session ticket，服务端支持，客户端开启 Okhttp中的Realconnection已支持session ticket。 优化前 优化后 False Start False Start是指客户端在发送Change CipherSpec Finished 同时发送应用数据(如HTTP请求)，服务端在TLS握手完成时直接返回应用数据。这样，应用数据的发送时机上未等到握手全部完成。开启FS之后，只需要一次RTT就可以开始传输数据，目前大部分浏览器默认都会支持启用，但也有一些前提条件： 服务端和客户端支持NPN或者ALPN 服务器配置支持前向安全性(ForwardSecrecy)的加密算法 配置方法为服务器配置Nginx或者Apache开启。 Certificate 证书实在握手期间发送的，由于TCP初始拥塞窗口的存在，如果证书太长可能会产生额外的往返开销。如果证书没包含中间证书，大部分浏览器可以正常工作，但会暂停验证并根据子证书指定的父证书URL自己获取中间证书。这个过程会产生额外的DNS解析、建立TCP连接等开销，非常影响性能。 配置证书的最佳实践： 证书链是只包含站点证书和中间证书，不要包含根证书，也不要漏掉中间证书。 减少证书大小，使用ECC（Elliptic Curve Cryptography，椭圆曲线密码学）证书。256位的ECC Key等同与3072位的RSA Key，在确保安全性的同事，体积大幅减少。 开启OCSP Stapling OCSP（Online Certificate Status Protocol，在线证书状态协议）是用来检验证书合法性的在线查询服务，一般由证书所属CA提供。某些客户端会在TLS握手阶段进一步协商时，实时查询OCSP接口，并在获得结果前阻塞后续流程。OCSP查询本质是一次完整的HTTP请求-响应，这中间的DNS查询、建立TCP、服务端处理等环节都可能耗费很长时间，导致最终建立TLS连接时间变得更长。 而OCSP Stapling，是指服务端主动获取OCSP查询结果并随证书一起发送给客户单，从而让客户端跳过自己验证的过程，提高TLS握手效率。 此过程由服务器Nginx配置开启。 WireShark配合tcpdump抓手机包 下载tcpdump，adb push ~/Downloads/tcpdump /data/local/tcpdump chmod 777 /data/local/tcpdump 进入root权限，su tcpdump -p -vv -s 0 -w /sdcard/capture.pcap adb pull /sdcard/capture.pcap ~/Downloads Wireshark打开pcap文件 名词解释 RTT(round-trip time) 对称算法 DES AES 非对称算法RSA DSA 参考链接 TLS 握手优化详解 HTTPS 原理以及优化实践 有货APP HTTPS优化探索和实践","categories":[],"tags":[{"name":"HTTPS 优化","slug":"HTTPS-优化","permalink":"http://yoursite.com/tags/HTTPS-优化/"}]},{"title":"Android进阶之Aspectj in Android入门","slug":"Android进阶之Aspectj-in-Android入门","date":"2019-01-14T07:56:40.000Z","updated":"2019-01-14T08:04:46.692Z","comments":true,"path":"2019/01/14/Android进阶之Aspectj-in-Android入门/","link":"","permalink":"http://yoursite.com/2019/01/14/Android进阶之Aspectj-in-Android入门/","excerpt":"","text":"背景AOP，Aspect-oriented programming，面向切面编程，是一种可以通过预编译方式和运行期动态代理实现在不修改源码的情况下给程序动态统一添加功能的技术。主要用途有日志记录，行为统计，安全控制，事务处理，异常处理，系统统一的认证、权限管理等 。 常见实现AOP编程库 AspectJ：和Java语言无缝衔接的面向切面的编程的扩展工具（可用于Android）。 Javassit for Android：一个移植到Android平台的非常知名的操纵字节码的java库。 DexMaker：用于在Dalvik VM编译时或运行时生成代码的基于java语言的一套API。 ASMDEX：一个字节码操作库（ASM），但它处理Android可执行文件（DEX字节码）。 要学习AspectJ，先理解其中一些概念。 Join Point：连接点，程序中可切入的点，例如方法调用时、读取某个变量时。 Pointcut ：切入点，代码注入的位置，其实就是有条件限定的 Join Point，例如只在特定方法中注入代码。 Advice：在切入点注入的代码，一般有 before、after、around 三种类型。 Target Object ：被一个或多个 aspect 横切拦截操作的目标对象。 Weaving： 把 Advice 代码织入到目标对象的过程。 Inter-type declarations : 用来给一个类型声明额外的方法或属性。 工程引入集成AspectJ主要有两种方式： 原始Gradle配置的方式： 项目根目录的build.gradle添加配置 1234567buildscript &#123; ... dependencies &#123; classpath 'org.aspectj:aspectjtools:1.8.6' ... &#125;&#125; 在app module的build.gradle文件中添加配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758apply plugin: 'com.android.application'android &#123; ...&#125;import org.aspectj.bridge.IMessageimport org.aspectj.bridge.MessageHandlerimport org.aspectj.tools.ajc.Mainfinal def log = project.loggerfinal def variants = project.android.applicationVariants//在构建工程时，执行编织variants.all &#123; variant -&gt; if (!variant.buildType.isDebuggable()) &#123; log.debug(\"Skipping non-debuggable build type '$&#123;variant.buildType.name&#125;'.\") return; &#125; JavaCompile javaCompile = variant.javaCompile javaCompile.doLast &#123; String[] args = [\"-showWeaveInfo\", \"-1.8\", \"-inpath\", javaCompile.destinationDir.toString(), \"-aspectpath\", javaCompile.classpath.asPath, \"-d\", javaCompile.destinationDir.toString(), \"-classpath\", javaCompile.classpath.asPath, \"-bootclasspath\", project.android.bootClasspath.join(File.pathSeparator)] log.debug \"ajc args: \" + Arrays.toString(args) MessageHandler handler = new MessageHandler(true); new Main().run(args, handler); for (IMessage message : handler.getMessages(null, true)) &#123; switch (message.getKind()) &#123; case IMessage.ABORT: case IMessage.ERROR: case IMessage.FAIL: log.error message.message, message.thrown break; case IMessage.WARNING: log.warn message.message, message.thrown break; case IMessage.INFO: log.info message.message, message.thrown break; case IMessage.DEBUG: log.debug message.message, message.thrown break; &#125; &#125; &#125;&#125;dependencies &#123; ... compile 'org.aspectj:aspectjrt:1.8.6'&#125; 插件的方式 ： Github上的开源插件 -AspectJX，一个基于AspectJ并在此基础上扩展出来可应用于Android开发平台的AOP框架，可作用于java源码，class文件及jar包，同时支持kotlin的应用，提供了AspectJ同样的功能。 在项目根目录的build.gradle里依赖AspectJX 123dependencies &#123; classpath 'com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.4'&#125; 在app项目的build.gradle里应用插件 123apply plugin: 'android-aspectjx'//或者这样也可以apply plugin: 'com.hujiang.android-aspectjx' 下面是使用 android-aspectjx 插件需要注意的点： android-aspectjx 插件是 使用在 application module 的插件，只能在编译 application module 的过程中织入代码。 AspectJ 的原理是在编译期注入代码，所以切面只能是项目代码、依赖的 jar 或 aar，不能注入 Android 平台 android.jar。例如，可以在 support 包的 Fragment 中注入代码，但是无法在 Activity 中注入代码，只能注入项目的继承自 Activity 的 XXActivity。 android-aspectjx 默认会遍历项目编译后所有的 .class 文件和依赖的第三方库去查找符合织入条件的切点，为了提升效率，可以加入过滤条件，具体见 Android Aspectjx 的文档。 简单Demo新建FragmentAspect类，添加注解，实现在Fragment调用onResume和onPause之前打印log 1234567891011121314151617181920212223@Aspectpublic class FragmentAspect &#123; private static final String TAG = \"FragmentAspect\"; @Pointcut(\"execution(void android.support.v4.app.Fragment.onResume()) &amp;&amp; target(fragment)\") public void resume(Fragment fragment) &#123; &#125; @Pointcut(\"execution(void android.support.v4.app.Fragment.onPause()) &amp;&amp; target(fragment)\") public void pause(Fragment fragment) &#123; &#125; @Before(\"resume(fragment)\") public void beforeOnResume(Fragment fragment) &#123; Log.d(TAG, fragment.getClass().getSimpleName() + \" onResume\"); &#125; @Before(\"pause(fragment)\") public void beforeOnPause(Fragment fragment) &#123; Log.d(TAG, fragment.getClass().getSimpleName() + \" onPause\"); &#125; &#125; 编译成功后找到MainFragment.class，已经生成注入代码 12345678910111213141516171819202122232425262728293031323334353637public class MainFragment extends Fragment &#123; private MainViewModel mViewModel; public MainFragment() &#123; &#125; public static MainFragment newInstance() &#123; return new MainFragment(); &#125; @Nullable public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; return inflater.inflate(2131296284, container, false); &#125; public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); this.mViewModel = (MainViewModel)ViewModelProviders.of(this).get(MainViewModel.class); &#125; public void onResume() &#123; FragmentAspect.aspectOf().beforeOnResume(this); try &#123; Thread.sleep(2000L); &#125; catch (InterruptedException var2) &#123; var2.printStackTrace(); &#125; super.onResume(); &#125; public void onPause() &#123; FragmentAspect.aspectOf().beforeOnPause(this); super.onPause(); &#125;&#125; 语法详解Join Point表示连接点，即AOP可织入代码的点，下表列出了AspectJ的所有连接点： Join Point 说明 Method call 方法被调用 Method execution 方法执行 Constructor call 构造函数被调用 Constructor execution 构造函数执行 Field get 读取属性 Field set 写入属性 Pre-initialization 与构造函数有关，很少用到 Initialization 与构造函数有关，很少用到 Static initialization static 块初始化 Handler 异常处理 Advice execution 所有 Advice 执行 具体语法： @Aspect AOP中的关键单位 - 切面，开发中一般将Pointcut和Advice放一个Aspect类中，在给予Aspect注解开发方式中只需要在类的头部加上@Aspect注解即可，@Aspect不可用于修饰接口。 @Pointcut 语法结构：@Pointcut(“Pointcut syntax”) 123@Pointcut(\"execution(void android.support.v4.app.Fragment.onResume()) &amp;&amp; target(fragment)\") public void resume(Fragment fragment) &#123;&#125; ​ Pointcuts 是具体的切入点，可以确定具体织入代码的地方，基本的 Pointcuts 是和 Join Point 相对应的。 Join Point Pointcuts syntax 说明 Method call call(MethodPattern) 方法被调用 Method execution execution(MethodPattern) 方法执行 Constructor call call(ConstructorPattern) 构造函数被调用 Constructor execution execution(ConstructorPattern) 构造函数执行 Field get get(FieldPattern) 读取属性 Field set set(FieldPattern) 写入属性 Pre-initialization initialization(ConstructorPattern) 对象预先初始化 Initialization preinitialization(ConstructorPattern) 对象初始化 Static initialization staticinitialization(TypePattern) static块初始化 Handler handler(TypePattern) 异常处理 Advice execution adviceexcution() 所有 Advice 执行 within(TypePattern) 符合 TypePattern 的代码中的 Join Point withincode(MethodPattern) 符合 TypePattern 的代码中的 Join Point withincode(ConstructorPattern) 在某些构造函数中的 Join Point cflow(Pointcut) Pointcut 选择出的切入点 P 的控制流中的所有 Join Point，包括 P 本身 cflowbelow(Pointcut) Pointcut 选择出的切入点 P 的控制流中的所有 Join Point，不包括 P 本身 this(Type or Id) Join Point 所属的 this 对象是否 instanceOf Type 或者 Id 的类型 target(Type or Id) Join Point 所在的对象（例如 call 或 execution 操作符应用的对象）是否 instanceOf Type 或者 Id 的类型 args(Type or Id, …) 方法或构造函数参数的类型 if(BooleanExpression) 满足表达式的 Join Point，表达式只能使用静态属性、Pointcuts 或 Advice 暴露的参数、thisJoinPoint 对象 ​ 上面 Pointcuts 的语法中涉及到一些 Pattern，下面是这些 Pattern 的规则，[]里的内容是可选的： Pattern 规则 MethodPattern [!] [@Annotation] [public,protected,private] [static] [final] [返回值类型] [类名.]方法名(参数类型列表) [throws 异常类型] ConstructorPattern [!] [@Annotation] [public,protected,private] [final] [类名.]new(参数类型列表) [throws 异常类型] FieldPattern [!] [@Annotation] [public,protected,private] [static] [final] 属性类型 [类名.]属性名 TypePattern 其他 Pattern 涉及到的类型规则也是一样，可以使用 ‘!’、’‘、’..’、’+’，’!’ 表示取反，’‘ 匹配除 . 外的所有字符串，’*’ 单独使用事表示匹配任意类型，’..’ 匹配任意字符串，’..’ 单独使用时表示匹配任意长度任意类型，’+’ 匹配其自身及子类，还有一个 ‘…’表示不定个数 ​ Pointcut 表达式还可以 ！、&amp;&amp;、|| 来组合，!Pointcut 选取不符合 Pointcut 的 Join Point，Pointcut0 &amp;&amp; Pointcut1 选取符合 Pointcut0 和 Pointcut1 的 Join Point，Pointcut0 || Pointcut1 选取符合 Pointcut0 或 Pointcut1 的 Join Point。 @Advice 语法结构：Advice(“Pointcut定义的方法”) 或者 Advice(“Pointcut表达式”) 1234@Before(\"resume(fragment)\") public void beforeOnResume(Fragment fragment) &#123; Log.d(TAG, fragment.getClass().getSimpleName() + \" onResume\");&#125; Advice 是在切入点上织入的代码，在 AspectJ 中有五种类型：Before、After、AfterReturning、AfterThrowing、Around。 Advice 说明 @Before 在执行 Join Point 之前 @After 在执行 Join Point 之后，包括正常的 return 和 throw 异常 @AfterReturning Join Point 为方法调用且正常 return 时，不指定返回类型时匹配所有类型 @AfterThrowing Join Point 为方法调用且抛出异常时，不指定异常类型时匹配所有类型 @Around 替代 Join Point 的代码，如果要执行原来代码的话，要使用 ProceedingJoinPoint.proceed() Advice注解修改的方法必须是public,Before、After、AfterReturning、AfterThrowing 四种类型修饰的方法返回值也必须为 void，Around的目标因为是替换原来的Joint Point，所以他会有返回值，一般是Object。Advice 需要使用 JoinPoint、JoinPointStaticPart、JoinPoint.EnclosingStaticPart时，要在方法中声明为额外的参数，@Around 方法可以使用 ProceedingJoinPoint，用以调用 proceed() 方法。 12345678@Around(\"execution(* com.example.tanhuanpei.learndemo..*.*(..))\") public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; long start = System.currentTimeMillis(); Object proceed = joinPoint.proceed(); long consume = System.currentTimeMillis() - start; Log.e(TAG, consume + \"ms \" + joinPoint.getSignature() + \" main thread method\"); return proceed;&#125; 至此，AspectJ在Android的应用入门介绍完毕。","categories":[],"tags":[{"name":"AspectJ 进阶","slug":"AspectJ-进阶","permalink":"http://yoursite.com/tags/AspectJ-进阶/"}]},{"title":"Android性能优化【应用启动优化与白屏源码分析】","slug":"Android性能优化【应用启动优化与白屏源码分析】","date":"2019-01-08T14:01:27.000Z","updated":"2019-01-08T14:03:34.388Z","comments":true,"path":"2019/01/08/Android性能优化【应用启动优化与白屏源码分析】/","link":"","permalink":"http://yoursite.com/2019/01/08/Android性能优化【应用启动优化与白屏源码分析】/","excerpt":"","text":"白屏是什么？在Android系统中，Activity组件在启动之后，并且在它的窗口显示出来之前，可以显示一个启动窗口。这个启动窗口可以看作是Activity组件的预览窗口，是由WindowManagerService服务统一管理的，即由WindowManagerService服务负责启动和结束。Activity组件的启动窗口是由ActivityManagerService服务来决定是否要显示的。如果需要显示，那么ActivityManagerService服务就会通知WindowManagerService服务来为正在启动的Activity组件显示一个启动窗口，而WindowManagerService服务又是通过窗口管理策略类PhoneWindowManager来创建这个启动窗口的。这个过程如图所示。 窗口管理策略类PhoneWindowManager创建完成Activity组件的启动窗口之后，就会请求WindowManagerService服务将该启动窗口显示出来。当Activity组件启动完成，并且它的窗口也显示出来的时候，WindowManagerService服务就会结束显示它的启动窗口。 如何检测App启动时间ADB命令adb shell am start -W -S com.xrom.intl.appcenter/com.xrom.intl.appcenter.ui.main.MainActivity12345Activity: com.xrom.intl.appcenter/.ui.main.MainActivityThisTime: 1258TotalTime: 1258WaitTime: 1328Complete WaitTime = endTime - startTime WaitTime就是总的耗时，包括前一个应用Activity pause的时间和新应用启动的时间；ThisTime表示一连串启动Activity的最后一个Activity的启动耗时；TotalTime表示新应用启动的耗时，包括新进程的启动和Activity的启动，但不包括前一个应用Activity pause的耗时。也就是说，开发者一般只要关心TotalTime即可，这个时间才是自己应用真正启动的耗时。 sysTrace工具Android的SDK开发包中platform-tools文件夹里包含了systrace工具，在使用命令之前可以配置参数和别名，避免重复敲命令。12alias st-start='python /home/tanhuanpei/IDE/Sdk/platform-tools/systrace/systrace.py'alias systrace='st-start -t 8 gfx input view sched freq wm am hwui workq res dalvik sync disk load perf hal rs idle mmc' 使用时1systrace -a com.xrom.intl.appcenter -o test.trace 启动时间分析使用adb命令和systrace命令生成test.trace文件 执行bindApplication从图中第一行可以看到,由于是第一次启动,这个应用的bindApplication方法被调用, 执行onCreate–onStart–onResume然后是activityStart方法,对应应用程序中的onCreate–onStart–onResume三个方法. 执行performTraversals紧接着会执行两次performTraversals方法(其源码位于Frameworks/base/core/java/android/view/ViewRootImpl.java), ViewRootImpl使用mFirst这个变量来标记是否是第一次启动.第一次执行performTraversals会执行mAttachInfo.mHardwareRenderer.initializ方法,初始化Surface. 第一次创建Surface之后,newSurface为true,从下面的代码来看会执行另一次performTraversals.这就是为什么启动应用的时候需要执行两次performTraversals.分析Trace图的时候也可以根据两次performTraversals执行的情况看出问题. 所以第二个performTraversals中会执行performDraw方法。 显示应用界面一般来说第二个performTraversals执行完成后, 表示应用程序的第一帧被绘制完成.一旦应用绘制完成,WMS会收到FINISHED_STARTING标记应用启动完成,这时会Remove掉Starting Window.这样应用就显示出来了. 应用启动优化的目标由于热启动和冷启动在优化方面的差异不大,就以最常见的的冷启动方式来确定优化的目标. 通过之前的知识可以知道,冷启动的耗时比较长,应用初始化的时间比较长.所以大部分人情况下Starting Window都是做完动画(即撑满屏幕)后,过一会儿才会被Remove掉. 从优化的角度来说,我们肯定是希望应用启动的时间越快越好.但是也要根据实际情况为其设置一个合理的数值. 启动优化的目标设定思路在手机使用方面,人的感官对于卡顿的感知是很灵敏的,同样对于加载时长的容忍也是很有限的,除非使用其他手段在加载时吸引用户的注意. 但是对于应用启动来说,用户的需求是非常明确的: 就是要快速打开应用,看到主界面.在用户点击到主界面显示,其中比较重要的可以优化的几个点: Starting Window的初始化 Starting Window的动画 应用的初始化时间 其中对应的可优化的点: 优化Starting Window的初始化时间(系统级优化) 优化Starting Window的动画(系统级优化,包括动画的时长,开始的大小,以及透明度等) 优化应用程序自身(应用级优化,包括精简onCreate/onStart/onResume函数,优化主界面的复杂度等) 从流畅性和连贯性的角度来说,如果在Starting Window刚好做完动画的时候,应用也初始化完成,这时候将Starting Window Remove掉.从用户的角度来看白屏没有停留,就显得很流畅. 从系统优化的角度来看,Android应用启动优化分为两个阶段的优化: 系统级服务的优化: ActivityManagerService的优化. WindowManagerService的优化. Touch Event的优化. Launcher的优化. 系统公共控件的优化. 应用相关的优化 应用布局优化. 懒加载: 即按需加载. 延迟加载: 即精简OnCreate函数. 参考链接怎么计算apk的启动时间","categories":[],"tags":[{"name":"性能优化 源码分析  白屏优化","slug":"性能优化-源码分析-白屏优化","permalink":"http://yoursite.com/tags/性能优化-源码分析-白屏优化/"}]},{"title":"Hexo简易教程","slug":"Hexo简易教程","date":"2018-12-18T07:55:18.031Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/12/18/Hexo简易教程/","link":"","permalink":"http://yoursite.com/2018/12/18/Hexo简易教程/","excerpt":"","text":"GitHub+Hexo 搭建个人网站详细教程 新建文章1$ hexo new \"My New Post\" 文章目录在 source/_posts/My Niew Post.mdMore info: Writing 启动本地服务器1$ hexo server 一般地址为 http://localhost:4000/More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程服务器1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Android架构组件-LiveData使用与源码分析","slug":"Android架构组件-LiveData使用与源码分析","date":"2018-12-18T07:39:37.000Z","updated":"2018-12-18T13:10:04.999Z","comments":true,"path":"2018/12/18/Android架构组件-LiveData使用与源码分析/","link":"","permalink":"http://yoursite.com/2018/12/18/Android架构组件-LiveData使用与源码分析/","excerpt":"","text":"前言LiveData是一个可以被观察的数据装载类。跟普通的被观察者不一样的，LiveData是具有生命周期感知功能，这意味它可以感知并遵循Activity,Fragment或者Service等组件的生命周期。这样的设计保证了LiveData仅当组件处于激活状态时才更新数据。 只有当 Observer 的 Lifecycle 对象处于 STARTED 或者 RESUMED 状态的时候， LiveData 才处于活动状态，只有在活动状态数据变化事件才会通知到 Observer。当处于DESTROYED状态的时候，Observer会被相应的移除。 LiveData的优点使用LiveData具有以下的有点： UI和实时数据保持一致 因为LiveData采用的是观察者模式，这样一来就可以在数据发生改变时获得通知，更新UI。避免内存泄漏- 观察者被绑定到组件的生命周期上，当被绑定的组件销毁（destroy）时，观察者会立刻自动清理自身的数据。不会再产生由于Activity处于stop状态而引起的崩溃- 例如：当Activity处于后台状态时，是不会收到LiveData的任何事件的。不需要再解决生命周期带来的问题- LiveData可以感知被绑定的组件的生命周期，只有在活跃状态才会通知数据变化。实时数据刷新- 当组件处于活跃状态或者从不活跃状态到活跃状态时总是能收到最新的数据。解决Configuration Change问题- 在屏幕发生旋转或者被回收再次启动，立刻就能收到最新的数据。资源共享- 通过使用单例模式和继承LiveData，可以实现一次发送，多个观察者更新数据。 添加LiveData添加google maven仓库在项目build.gradle中添加：123456allprojects &#123; repositories &#123; google() jcenter() &#125;&#125; AndroidX1234567891011121314dependencies &#123; def lifecycle_version = &quot;2.0.0&quot; // ViewModel and LiveData implementation &quot;androidx.lifecycle:lifecycle-extensions:$lifecycle_version&quot; // alternatively - just LiveData implementation &quot;androidx.lifecycle:lifecycle-livedata:$lifecycle_version&quot; // optional - ReactiveStreams support for LiveData implementation &quot;androidx.lifecycle:lifecycle-reactivestreams:$lifecycle_version&quot; // use -ktx for Kotlin // optional - Test helpers for LiveData testImplementation &quot;androidx.arch.core:core-testing:$lifecycle_version&quot;&#125; AndroidX之前12345678910111213dependencies &#123; def lifecycle_version = &quot;1.1.1&quot; // ViewModel and LiveData implementation &quot;android.arch.lifecycle:extensions:$lifecycle_version&quot; // alternatively - just LiveData implementation &quot;android.arch.lifecycle:livedata:$lifecycle_version&quot; // optional - ReactiveStreams support for LiveData implementation &quot;android.arch.lifecycle:reactivestreams:$lifecycle_version&quot; // optional - Test helpers for LiveData testImplementation &quot;android.arch.core:core-testing:$lifecycle_version&quot;&#125; 创建LiveData对象MutableLiveData1234567891011121314public class NameViewModel extends ViewModel &#123;// Create a LiveData with a Stringprivate MutableLiveData&lt;String&gt; mCurrentName; public MutableLiveData&lt;String&gt; getCurrentName() &#123; if (mCurrentName == null) &#123; mCurrentName = new MutableLiveData&lt;String&gt;(); &#125; return mCurrentName; &#125;// Rest of the ViewModel...&#125; 123456789101112131415161718192021222324252627public class NameActivity extends AppCompatActivity &#123; private NameViewModel mModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Other code to setup the activity... // Get the ViewModel. mModel = ViewModelProviders.of(this).get(NameViewModel.class); // Create the observer which updates the UI. final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; // Update the UI, in this case, a TextView. mNameTextView.setText(newName); &#125; &#125;; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. mModel.getCurrentName().observe(this, nameObserver); &#125;&#125; MediatorLiveData123456LiveData liveData1 = ...;LiveData liveData2 = ...;MediatorLiveData liveDataMerger = new MediatorLiveData&lt;&gt;();liveDataMerger.addSource(liveData1, value -&gt; liveDataMerger.setValue(value));liveDataMerger.addSource(liveData2, value -&gt; liveDataMerger.setValue(value)); 使用单例模式 1234567891011121314151617181920212223242526272829public class SingletonLiveData extends MutableLiveData&lt;String&gt; &#123; private static volatile SingletonLiveData instance; public SingletonLiveData() &#123; &#125; public static SingletonLiveData getInstance() &#123; if (instance != null) &#123; return instance; &#125; synchronized (SingletonLiveData.class) &#123; if (instance == null) &#123; instance = new SingletonLiveData(); &#125; &#125; return instance; &#125; @Override protected void onActive() &#123; super.onActive(); &#125; @Override protected void onInactive() &#123; super.onInactive(); &#125;&#125; 123456SingletonLiveData.getInstance().observe(this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable String s) &#123; &#125; &#125;); 1SingletonLiveData.getInstance().setValue(&quot;single&quot;); 简单说明LiveData中的几个重要方法：onActive() - ：当 LiveData 具有活动状态的 Observer 的时候会调用这个函数。在这个函数中，我们开始监听位置变化。onInactive()- ：当 LiveData 没有活动状态的 Observer 的时候会调用这个函数。所以在这个函数中取消更新位置来避免无所谓的耗电。setValue()- ： 当 LiveData 的数据变化的时候，调用这个函数。然后 LiveData 会通知活动状态的 Observer 数据变化了。postValue()- :当需要在非UI线程更新数据时调用此函数。 需要注意的是，当使用 LiveData 时，由于CREATED 和 RESUMED 状态都被认为是激活状态，所以我们需要在 onCreate 中设置 LiveData并开始监听，如果监听放到 onResume 函数中的话，当 Activity 暂停再次恢复的时候，会调用 onStart 和 onResume 导致 LiveData 的 onActive() 函数分别被调用两次。 数据转换LiveData 还支持简单的数据变换。目前在 Transformations 类中有 map 和 switchMap 两个变换函数。 map 是把一个数据类型变换为另外一个数据类型。 switchMap 是把一个数据变化为另外一个 LiveData 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); 12345678910111213141516class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; private final MutableLiveData&lt;String&gt; addressInput = new MutableLiveData(); public final LiveData&lt;String&gt; postalCode = Transformations.switchMap(addressInput, (address) -&gt; &#123; return repository.getPostCode(address); &#125;); public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository &#125; private void setInput(String address) &#123; addressInput.setValue(address); &#125;&#125; 原理分析下面，我们深入源码，简单分析LiveData如何做到生命周期感知。先从注册观察者入手，源码中LiveData的observe方法如下1234567891011121314151617@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); LifecycleBoundObserver existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; existing.owner != wrapper.owner) &#123; throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper);&#125; 从这段代码看出，当观察者所在的LifecycleOwner状态处于DESTROYED时，注册失败。当重复注册观察者时，会抛出IllegalArgumentException异常。通过这些验证后，向Lifecycle注册观察者observer，LifecycleBoundObserver只是observer的一个包装类。LifecycleOwner是一个接口，只有一个方法getLifecycle()，在Fragment、FragmentActivity、SupportActivity、LifecycleService中均实现了这个方法。 12345678910111213141516171819202122232425262728293031323334353637383940class LifecycleBoundObserver implements GenericLifecycleObserver &#123; public final LifecycleOwner owner; public final Observer&lt;T&gt; observer; public boolean active; public int lastVersion = START_VERSION; LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; this.owner = owner; this.observer = observer; &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(observer); return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner activeStateChanged(isActiveState(owner.getLifecycle().getCurrentState())); &#125; void activeStateChanged(boolean newActive) &#123; if (newActive == active) &#123; return; &#125; active = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += active ? 1 : -1; if (wasInactive &amp;&amp; active) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !active) &#123; onInactive(); &#125; if (active) &#123; dispatchingValue(this); &#125; &#125; &#125; 123456789public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; 123456789101112131415161718192021222324252627282930public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner &#123; LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; void performStart() &#123; if (mChildFragmentManager != null) &#123; mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(); &#125; mState = STARTED; mCalled = false; onStart(); if (!mCalled) &#123; throw new SuperNotCalledException(\"Fragment \" + this + \" did not call through to super.onStart()\"); &#125; if (mChildFragmentManager != null) &#123; mChildFragmentManager.dispatchStart(); &#125; if (mLoaderManager != null) &#123; mLoaderManager.doReportStart(); &#125; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); &#125;&#125; LiveData中内部类LifecycleBoundObserver12345678910111213141516171819202122232425262728293031323334353637383940class LifecycleBoundObserver implements GenericLifecycleObserver &#123; public final LifecycleOwner owner; public final Observer&lt;T&gt; observer; public boolean active; public int lastVersion = START_VERSION; LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; this.owner = owner; this.observer = observer; &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(observer); return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner activeStateChanged(isActiveState(owner.getLifecycle().getCurrentState())); &#125; void activeStateChanged(boolean newActive) &#123; if (newActive == active) &#123; return; &#125; active = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += active ? 1 : -1; if (wasInactive &amp;&amp; active) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !active) &#123; onInactive(); &#125; if (active) &#123; dispatchingValue(this); &#125; &#125; &#125; LifecycleRegistry.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310public class LifecycleRegistry extends Lifecycle &#123; private static final String LOG_TAG = \"LifecycleRegistry\"; /** * Custom list that keeps observers and can handle removals / additions during traversal. * * Invariant: at any moment of time for observer1 &amp; observer2: * if addition_order(observer1) &lt; addition_order(observer2), then * state(observer1) &gt;= state(observer2), */ private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;(); /** * Current state */ private State mState; /** * The provider that owns this Lifecycle. * Only WeakReference on LifecycleOwner is kept, so if somebody leaks Lifecycle, they won't leak * the whole Fragment / Activity. However, to leak Lifecycle object isn't great idea neither, * because it keeps strong references on all other listeners, so you'll leak all of them as * well. */ private final WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner; private int mAddingObserverCounter = 0; private boolean mHandlingEvent = false; private boolean mNewEventOccurred = false; // we have to keep it for cases: // void onStart() &#123; // mRegistry.removeObserver(this); // mRegistry.add(newObserver); // &#125; // newObserver should be brought only to CREATED state during the execution of // this onStart method. our invariant with mObserverMap doesn't help, because parent observer // is no longer in the map. private ArrayList&lt;State&gt; mParentStates = new ArrayList&lt;&gt;(); /** * Creates a new LifecycleRegistry for the given provider. * &lt;p&gt; * You should usually create this inside your LifecycleOwner class's constructor and hold * onto the same instance. * * @param provider The owner LifecycleOwner */ public LifecycleRegistry(@NonNull LifecycleOwner provider) &#123; mLifecycleOwner = new WeakReference&lt;&gt;(provider); mState = INITIALIZED; &#125; /** * Moves the Lifecycle to the given state and dispatches necessary events to the observers. * * @param state new state */ @SuppressWarnings(\"WeakerAccess\") @MainThread public void markState(@NonNull State state) &#123; moveToState(state); &#125; /** * Sets the current state and notifies the observers. * &lt;p&gt; * Note that if the &#123;@code currentState&#125; is the same state as the last call to this method, * calling this method has no effect. * * @param event The event that was received */ public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next); &#125; private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false; &#125; private boolean isSynced() &#123; if (mObserverMap.size() == 0) &#123; return true; &#125; State eldestObserverState = mObserverMap.eldest().getValue().mState; State newestObserverState = mObserverMap.newest().getValue().mState; return eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState; &#125; private State calculateTargetState(LifecycleObserver observer) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer); State siblingState = previous != null ? previous.getValue().mState : null; State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1) : null; return min(min(mState, siblingState), parentState); &#125; @Override public void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--; &#125; private void popParentState() &#123; mParentStates.remove(mParentStates.size() - 1); &#125; private void pushParentState(State state) &#123; mParentStates.add(state); &#125; @Override public void removeObserver(@NonNull LifecycleObserver observer) &#123; // we consciously decided not to send destruction events here in opposition to addObserver. // Our reasons for that: // 1. These events haven't yet happened at all. In contrast to events in addObservers, that // actually occurred but earlier. // 2. There are cases when removeObserver happens as a consequence of some kind of fatal // event. If removeObserver method sends destruction events, then a clean up routine becomes // more cumbersome. More specific example of that is: your LifecycleObserver listens for // a web connection, in the usual routine in OnStop method you report to a server that a // session has just ended and you close the connection. Now let's assume now that you // lost an internet and as a result you removed this observer. If you get destruction // events in removeObserver, you should have a special case in your onStop method that // checks if your web connection died and you shouldn't try to report anything to a server. mObserverMap.remove(observer); &#125; /** * The number of observers. * * @return The number of observers. */ @SuppressWarnings(\"WeakerAccess\") public int getObserverCount() &#123; return mObserverMap.size(); &#125; @Override public State getCurrentState() &#123; return mState; &#125; static State getStateAfter(Event event) &#123; switch (event) &#123; case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException(\"Unexpected event value \" + event); &#125; private static Event downEvent(State state) &#123; switch (state) &#123; case INITIALIZED: throw new IllegalArgumentException(); case CREATED: return ON_DESTROY; case STARTED: return ON_STOP; case RESUMED: return ON_PAUSE; case DESTROYED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException(\"Unexpected state value \" + state); &#125; private static Event upEvent(State state) &#123; switch (state) &#123; case INITIALIZED: case DESTROYED: return ON_CREATE; case CREATED: return ON_START; case STARTED: return ON_RESUME; case RESUMED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException(\"Unexpected state value \" + state); &#125; private void forwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); &#125; &#125; &#125; private void backwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); &#125; &#125; &#125; // happens only on the top of stack (never in reentrance), // so it doesn't have to take in account parents private void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; Log.w(LOG_TAG, \"LifecycleOwner is garbage collected, you shouldn't try dispatch \" + \"new events from it.\"); return; &#125; while (!isSynced()) &#123; mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false; &#125; static State min(@NonNull State state1, @Nullable State state2) &#123; return state2 != null &amp;&amp; state2.compareTo(state1) &lt; 0 ? state2 : state1; &#125; static class ObserverWithState &#123; State mState; GenericLifecycleObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.getCallback(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125; &#125;&#125; 取Fragment举例，当Fragment状态切换调用perforStart()时，会执行LifecycleRegistry的handleLifecycleEvent()，然后依次调用moveToState()-&gt;sync()-&gt;forwardPass()-&gt;内部类ObserverWithState.dispatchEvent(LifecycleOwner owner, Event event)，然后调用LiveData中内部类LifecycleBoundObserver的onStateChanged()，当状态为DESTROYED时，自动解除绑定observer，实现了生命周期感知，避免内存泄露。 到这里，我们已经了解到LiveData绑定观察者和解绑观察者的流程。下面我们看下数据是怎么实现更新的。 1234567891011121314151617181920212223242526272829303132protected void setValue(T value) &#123; assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null); &#125;protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125;private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125; &#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void dispatchingValue(@Nullable LifecycleBoundObserver initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, LifecycleBoundObserver&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false; &#125;private void considerNotify(LifecycleBoundObserver observer) &#123; if (!observer.active) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!isActiveState(observer.owner.getLifecycle().getCurrentState())) &#123; observer.activeStateChanged(false); return; &#125; if (observer.lastVersion &gt;= mVersion) &#123; return; &#125; observer.lastVersion = mVersion; //noinspection unchecked observer.observer.onChanged((T) mData); &#125; 在LiveData中setVaule和postValue方法最终结果都是一样的，只是postValue提供给在非UI线程中调用。这里有个逻辑需要注意，在这篇文章中已经讲的很清晰，当LifeCircleOwner的状态发生变化的时候，会调用LiveData.ObserverWrapper的activeStateChanged函数，如果这个时候ObserverWrapper的状态是active，就会调用LiveData的dispatchingValue，接着调用considerNotify方法。在LiveData的considerNotify方法中，如果ObserverWrapper的mLastVersion小于LiveData的mVersion，就会去回调mObserver的onChanged方法。而每个新的订阅者，其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveDataBus每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。 总结上面已经介绍了LiveData的使用方法和通过源码分析一遍实现原理。通过LifecycleRegistry类将Fragment、Activity和Service组件的生命周期绑定到LiveData上，并通过观察者模式实现了数据的更新。","categories":[],"tags":[]},{"title":"Android性能优化【ANR机制总结与问题分析】","slug":"Android性能优化【ANR机制总结与问题分析】","date":"2018-09-12T12:36:22.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/09/12/Android性能优化【ANR机制总结与问题分析】/","link":"","permalink":"http://yoursite.com/2018/09/12/Android性能优化【ANR机制总结与问题分析】/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"工具汇总","slug":"工具汇总","date":"2018-08-01T02:54:12.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/08/01/工具汇总/","link":"","permalink":"http://yoursite.com/2018/08/01/工具汇总/","excerpt":"","text":"反编译Jadx","categories":[],"tags":[]},{"title":"Android性能优化【数据结构篇】","slug":"Android性能优化【数据结构篇】","date":"2018-07-27T07:42:56.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/07/27/Android性能优化【数据结构篇】/","link":"","permalink":"http://yoursite.com/2018/07/27/Android性能优化【数据结构篇】/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用AS开发gradle插件 (一)","slug":"使用AS开发gradle插件入门","date":"2018-07-05T11:45:51.000Z","updated":"2018-12-18T07:55:18.031Z","comments":true,"path":"2018/07/05/使用AS开发gradle插件入门/","link":"","permalink":"http://yoursite.com/2018/07/05/使用AS开发gradle插件入门/","excerpt":"","text":"0X00 前言Gradle是一个使用Groovy语言实现的用于构建项目的框架。构建项目时真正起作用的是基于gradle框架使用Groovy实现的各种gradle插件。Gradle默认提供了很多插件，如Java-Plugin、Maven-Plugin等。Android Studio使用的是Android-Gradle-Plugin，由Google自主开发。在Android项目中，一个build.gradle文件，其实就是一个Groovy类。 0X01 在项目中使用Android gradle插件配置插件路径，在Project目录中的build.gradle添加123dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos;&#125; 使用具体插件，在主Module目录中的build.gradle添加1apply plugin: &apos;com.android.application&apos; 0X02 自定义插件我们可以利用Android Studio进行gradle插件开发，使用Groovy语言。简单步骤如下，1.新建一个Module，选择Android Library。2.删除src文件夹下的mian文件夹、删除build.gradle账文件中的所有内容。3.在src目录下创建 groovy和resources目录，resouces目录下创建META-INF/gradle-plugins目录。创建完后的文件目录结构如下图：4.修改Module中的 build.gradle文件，引入groovy和maven相关依赖1234567apply plugin: &apos;groovy&apos;apply plugin: &apos;maven&apos;dependencies &#123; compile gradleApi() compile localGroovy()&#125; 5.创建插件类TimeImpl.groovy，继承 Plugin&lt;Project&gt;，实现apply方法。 1234567public class TimeImpl implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; project.gradle.addListener(new TimeListener()) &#125;&#125; 在gradle-plugins文件夹下创建properties文件，文件名就是以后插件的名字。配置插件类1implementation-class = com.thp.plugin.TimeImpl 6.在build.gradle配置插件版本和发布到本地仓库 12345678910group = &apos;com.thp.plugin&apos;version = &apos;1.0.0&apos;uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri(&apos;../repo&apos;)) &#125; &#125;&#125; 这时候，右侧的gradle Toolbar就会在module下多出一个task 点击uploadArchives，项目目录多出repo文件夹，打开可以看到生成的gradle插件 0X03 项目中引用插件在app module的build.gradle上添加1234567891011121314buildscript &#123; repositories &#123; jcenter() maven &#123; url uri(&apos;../repo&apos;) &#125; &#125; dependencies &#123; classpath &apos;com.thp.plugin:gradletime:1.0.0&apos; &#125;&#125;apply plugin: &apos;gradle.time&apos; 以上，就是一个自定义插件的开发和引用流程。在这里，我们是引用本地生成的插件文件，下一篇将介绍如何上传到jcenter上，方便引用。 中文文档 深入理解Android之Gradle-邓凡平 Gradle User Guide 中文版 拥抱Android Studio系列 外籍文档 Groovy Documentation ：Groovy 的详细介绍文档 Groovy API Reference ：Groovy 的 API 文档 Gradle User Guid：Gradle 的详细介绍文档 Gradle Build Language Reference : Gradle DSL 参考，重点的几个 DSL 过一下，其他的用到再查 Android Plugin DSL Reference : 使用 Android 插件必备","categories":[],"tags":[{"name":"gradle插件","slug":"gradle插件","permalink":"http://yoursite.com/tags/gradle插件/"}]}]}